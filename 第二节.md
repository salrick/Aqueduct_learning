# 开始
## 安装
1. 安装dart
    我自己使用VScode的dart扩展（还有一些其它安装方法及其步骤可以在X站找到教程）
2. 激活Aqueduct
    pub global activate aqueduct
3. 创建新项目
    aqueduct create my_project
  
**学习Aqueduct之前应该先了解HTTP的响应原理**

## 创建项目
### 创建默认模板
aqueduct create my_project_name
### 创建列表模板 
aqueduct create list-templates
### 提供模板的名字来使用该模板创建项目
aqueduct create -t db my_project_name

我在学习文件夹的目录下创建了三个文件夹并在单独的文件夹中尝试了这三个建立模板项目的代码。
其中
>aqueduct create list-templates 
似乎没有产生新的项目

## 使用Aqueduct ORM
Aqueduct ORM使用PostgreSQL.
<font color=gray>这里要先安装PostgreSQL</font>
创建项目时，请使用数据库模板。

# 教程
## 开始
在本教程结束时，您将创建一个从PostgreSQL数据库中为虚构hero服务的Aqueduct应用程序。

**学习内容：**

<li>将HTTP请求路由到代码中的适当处理程序
<li>存储和检索数据库数据
<li>为每个端点编写自动化测试
<li>要求对HTTP请求进行授权

### 1.安装
搭建好dart环境以后，使用
> pub global activate aqueduct
安装
### 2.创建项目
用终端创建项目，名为hero

>aqueduct create heroes

使用以下地址访问案例页面

>http://localhost:8888/example


第一章中，您将编写代码来处理两个请求：一个获取英雄列表，另一个通过其标识符获取单个英雄。这些要求是：
GET /heroes to the list of heroes
GET /heroes/:id to get an individual hero
### 3.处理HTTP请求
在lib中新建controller/heroes_controller.dart，然后填入以下代码

```import 'package:aqueduct/aqueduct.dart';
import 'package:heroes/heroes.dart';

class HeroesController extends Controller {
  final _heroes = [
    {'id': 11, 'name': 'Mr. Nice'},
    {'id': 12, 'name': 'Narco'},
    {'id': 13, 'name': 'Bombasto'},
    {'id': 14, 'name': 'Celeritas'},
    {'id': 15, 'name': 'Magneta'},    
  ];

  @override
  Future<RequestOrResponse> handle(Request request) > async {
    return Response.ok(_heroes);
  }
}
```
在channel.dart文件首添加
```
import 'controller/heroes_controller.dart';
```
并替换entryPoint中的内容
```
@override
Controller get entryPoint {
  final router = Router();

  router
    .route('/heroes')
    .link(() => HeroesController());

  router
    .route('/example')
    .linkFunction((request) async {
      return Response.ok({'key': 'value'});
    });

  return router;
}
```
完成更改后保存所有更改。
在命令行中输入
```
aqueduct serve
```
运行程序，然后可以在浏览器中访问
```
http://localhost:8888/heroes
```
可以通过
```
curl -X GET http://localhost:8888/heroes
```
查看请求的实际响应
### 4.高级路由
修改heroes_controller.dart中的内容，除了import部分全部用以下内容替换
```
class HeroesController extends ResourceController {
  final _heroes = [
    {'id': 11, 'name': 'Mr. Nice'},
    {'id': 12, 'name': 'Narco'},
    {'id': 13, 'name': 'Bombasto'},
    {'id': 14, 'name': 'Celeritas'},
    {'id': 15, 'name': 'Magneta'},
  ];

  @Operation.get()
  Future<Response> getAllHeroes() async {
    return Response.ok(_heroes);
  }

  @Operation.get('id')
  Future<Response> getHeroByID() async {
    final id = int.parse(request.path.variables['id']);
    final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null);
    if (hero == null) {
      return Response.notFound();
    }

    return Response.ok(hero);
  }
}
```
之后可以使用
```
http://localhost:8888/heroes/11
```
访问单个hero（http://localhost:8888/heroes访问全部heroes）
### 请求绑定
<font color=gray>这部分没有从原文中提取到对现在有帮助的信息</font>
<font color=gray>这是原文：</font>
<font color=gray>In our getHeroByID method, we make a dangerous assumption that the path variable 'id' can be parsed into an integer. If 'id' were something else, like a string, int.parse would throw an exception. When exceptions are thrown in operation methods, the controller catches it and sends a 500 Server Error response. 500s are bad, they don't tell the client what's wrong. A 404 Not Found is a better response here, but writing the code to catch that exception and create this response is cumbersome.

Instead, we can rely on a feature of operation methods called request binding. An operation method can declare parameters and bind them to properties of the request. When our operation method gets called, it will be passed values from the request as arguments. Request bindings automatically parse values into the type of the parameter (and return a better error response if parsing fails). Change the method getHeroByID():</font>
**<font color=gray>这是一些可能要记住的东西（来自百度翻译）：</font>**
<font color=gray>在getHeroByID方法中，我们假设路径变量'id'可以解析为整数，这是一个危险的假设。</font>
<font color=gray>当操作方法中抛出异常时，控制器捕获异常并发送500服务器错误响应。500是一个糟糕的情况</font>
<font color=gray>可以依赖操作方法的一个特性，称为请求绑定。操作方法可以声明参数并将它们绑定到请求的属性。当我们的操作方法被调用时，它将作为参数从请求中传递值。请求绑定自动将值解析为参数类型（如果解析失败，则返回更好的错误响应）</font>
以下为需要替换的代码：
```
@Operation.get('id')
Future<Response> getHeroByID(@Bind.path('id') int id) async {
  final hero = _heroes.firstWhere((hero) => hero['id'] == id, orElse: () => null);

  if (hero == null) {
    return Response.notFound();
  }

  return Response.ok(hero);
}
```

下面这段文字里有一些说明、注意事项，可能需要保留英文关键字

>The value of the path variable id will be parsed as an integer and be available to this method in the id parameter. The @Bind annotation on an operation method parameter tells Aqueduct the value from the request we want bound. Using the named constructor Bind.path binds a path variable, and the name of that variable is indicated in the argument to this constructor.
You can bind path variables, headers, query parameters and bodies. When binding path variables, we have to specify which path variable with the argument to @Bind.path(pathVariableName).

>**Bound Parameter Names**
>>The name of a bound parameter doesn't have to match the name of the path variable. We could have declared it as @Bind.path('id') int heroID. Only the argument to Bind's constructor must match the actual name of the path variable. This is valuable for other types of bindings, like headers, that may contain characters that aren't valid Dart variable names, e.g. X-API-Key.

## 本段教程结束
在这个简单的练习中，我们使用一个恒定的英雄列表作为数据源，制作了一个demo
