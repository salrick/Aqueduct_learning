# 第一节：核心概念

## 资源

原文：

> Resources
>
> Resources are the things your application exposes through its HTTP API. A resource can be anything - a user profile in an application, a temperature sensor in Antarctica, or a high score for a game. For example, the GitHub API exposes organization, repository, issue and pull request resources; a social network API has profiles, posts, and user relationships.
>
> 
>
> Resources are organized into collections (e.g., all of the posts), for which individual resources within that collection can be uniquely identified (e.g., a single post). Requests are made to an application to retrieve the state of a resource or to provide the desired state of a resource. Most often, resources are represented as JSON arrays and objects. When retrieving a resource, its JSON representation is encoded into the response body. When providing the desired state of a resource, a client sends the JSON representation of the desired resource state in the request body.

### 个人笔记
#### 重点：
资源是应用程序通过其HTTP API公开的内容。大多数情况下，资源表示为JSON数组和对象。
#### 个人理解：
资源是应用程序通信时交流的内容，其传递形式常为json文件。

## 路由

原文：

>Resources are identified by the path of an HTTP request. For example, the URL http://example.com/organizations identifies the collection of organization resources on the server http://example.com. The URL http://example.com/organizations/1 identifies a single organization.

>An application exposes routes for each resource it manages. A route is a string that matches the path of a request. When a request's path matches a route, the associated handler is invoked to handle the request. Routes look like paths, but have some additional syntax. For example, the route /organizations will match requests with the path /organizations. The route /organizations/:id will match the paths /organizations/1, /organizations/2, and so on.

### 个人笔记
#### 重点：
路由是与请求路径匹配的字符串。
路由看起来像路径，但是有一些额外的语法。
#### 个人理解：
打比方：路由就像四通八达的高速路，它看起来像地图导航查出来的路线（但是有着自己的表达方式），但其实它的本质是高速路通行证

## 控制器

原文：
>Controllers are objects that handle requests. For example, a controller might fetch rows from a database and send them to the client in the response body. Another controller might verify the username and password of a request's Authorization header are valid.

>Controllers are linked together to form a series of actions to take for a request. These linked together controllers are called a channel. If the above examples were linked together, the channel would check if a request were authorized before it sent a response containing database rows.

>There are two flavors of controllers. An endpoint controller performs operations on a resource or resource collection, and always sends a response. Endpoint controllers fulfill requests by returning the state of a resource or by changing the state of a resource. You write most of your application-specific logic endpoint controllers.

>A middleware controller takes an action for a request, but isn't responsible for fulfilling the request. Middleware controllers can do many different things and are often reusable in many channels. Most often, a middleware controller validates something about a request before it reaches an endpoint controller. Middleware controllers can send a response for a request, and doing so prevents any other controller in that channel from handling the request.

>A channel must have exactly one endpoint controller. It can be preceded by zero or more middleware controllers. See the guides on Controllers and ResourceControllers for usage details.

### 个人笔记
#### 重点：
控制器是处理请求的对象。
控制器被连接在一起，形成一系列的动作来处理请求。这些连接在一起的控制器称为**通道**。
控制器有两种：
1. 端点控制器（处理资源及其集合，并做出响应动作）
2. 中间件控制器（对请求执行操作，但不负责完成请求）
通道必须只有一个端点控制器。它前面可以有零个或多个中间件控制器。
#### 个人理解：
控制器是一个函数。
·案例1：响应请求，返回数据；
·案例2：验证用户输入的信息；
一系列被视为控制器的函数共同构成了**通道（channel）**；
控制器的类型有两种，分类类似于单链中的头结点和子节点；
-端点控制器类似于头结点，但是位置位于链条的末端，入口接收信息，出口响应请求。
-中间件控制器类似于所有的子节点，入口接收信息，出口传给下一个子节点。
**一个通道只能有一个端点控制器，零个或多个中间件控制器**

##应用通道
原文：
>The application channel is an object that contains all of the controllers in an application. It designates one controller as the first controller to receive every request called its entry point. Controllers are linked to the entry point (directly or transitively) to form the entire application channel. In nearly every application, the entry point is a router; this controller splits the channel into sub-channels for a given route.

>The application channel is also responsible for initializing the application's services, reading configuration files and other startup related tasks. See the guide on the Application Channel for more details.



### 个人笔记
#### 重点：
应用通道是包含应用程序中所有控制器的对象。
应用通道指定一个控制器作为入口，来接受所有请求。
所有的控制器直接地或间接地连接到入口控制器，这一关系实体构成了应用通道。
（几乎）所有的程序都以路由为入口控制器，这个路由负责分配子通道。
应用通道还负责所有的初始化工作。
#### 个人理解：
这里再次验证了，控制器就是函数，入口控制器类似于入口函数main，分配子路由的任务类似于主函数决定要调用其它哪个函数。
应用通道是所有通道的总称，这一名词包含：
1. 函数
2. 函数之间的关系

##服务
原文：
>A service is an object that encapsulates complex tasks or algorithms, external communication or tasks that will be reused across an application. The purpose of a service object is to provide a simple interface to more detailed behavior. For example, a database connection is a service object; a user of a database connection doesn't know the details of how the connection is made or how to encode the query onto the wire, but it can still execute queries.

>The primary user of service objects are controllers. Services are injected into controllers by passing them as arguments to the controller's constructor. The controller keeps a reference to the service, so that it can use it when handling a request.



### 个人笔记
#### 重点：
服务是一个对象，它封装了复杂的任务或算法、外部通信或将在应用程序中重用的应用。
它的存在是为了简化接口。
服务的主要用户是控制器。
将服务作为参数传递给控制器的构造函数，从而使控制器拥有这些服务的功能。
#### 个人理解：
服务类似于一个包，把它作为参数传给控制器（函数），使得该控制器可以调用包里面的函数。

##隔离
原文：
>Isolates are memory-isolated threads; an object created on one isolate can't be referenced by another isolate. When an application starts, one or more isolates containing replicas of your application code are spawned. This behavior effectively 'load balances' your application across multiple threads.

>A benefit to this structure is that each isolate has its own set of services, like database connections. This eliminates the need for techniques like 'database connection pooling', because the entire application is effectively 'pooled'.


### 个人笔记
#### 重点：
隔离是内存隔离线程；在一个隔离上创建的对象不能被另一个隔离引用。
当应用程序启动时，将生成一个或多个包含应用程序代码副本的隔离。
这种结构的一个好处是，每个隔离都有自己的一组服务，比如数据库连接。
这样就不需要像“数据库连接池”这样的技术，因为整个应用程序都是有效的“池”。
#### 个人理解：
或许是将应用内的各个任务分配到不同的进程，来杜绝进程间的相互影响。

##绑定
原文：
>A request might contain headers, query parameters, a body and path parameters that need to be parsed, validated and used in controller code. Bindings are annotations added to variables that perform this parsing and validation automatically. Appropriate error responses are sent when a bound value can't be parsed into expected type or validation fails.

>Bindings cut down on boiler plate code and reduce testing surface, making development faster and code easier to reason about. For more information on bindings, see the guide on Resource Controllers.

### 个人笔记
#### 重点：
绑定是添加到自动执行此分析和验证的变量的注释。
当绑定值无法解析为预期类型或验证失败时，将发送相应的错误响应。
请求可能包含头、查询参数、需要在控制器代码中分析、验证和使用的主体和路径参数。
#### 个人理解：
绑定使开发得到了简化。
在调用控制器前，先使用绑定对请求进行过滤。

##查询和数据模型
原文：
>Application store information in databases for persistence. Writing database queries by hand is error-prone and doesn't leverage static analysis tools that are so valuable in a Dart application. Aqueduct's ORM (Object-Relational Mapping) provides statically-typed queries that are easy to write and test.

>Your application's data model is defined by creating Dart classes. Each class is mapped to a database table, and each property of that class is mapped to a column in that table. Aqueduct's command-line tool generates database migration files that detect changes in your data model that can be applied to a live, versioned database. A data model can also be represented as a JSON object to build tools on top of your application.

### 个人笔记
#### 重点：
Aqueduct的ORM（对象关系映射）提供静态类型的查询，这些查询易于编写和测试。
应用的数据模型是通过创建Dart类来定义的。每个类都映射到数据库表，并且该类的每个属性都映射到该表中的列。

##其它
### 个人笔记
Aqueduct默认使用PostgreSQL数据库

